<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>JAEYOUNGYUN</title>
        <link>https://korjaeyoungyun.github.io/</link>
        <description>Recent content on JAEYOUNGYUN</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 24 Jul 2022 10:10:45 +0900</lastBuildDate><atom:link href="https://korjaeyoungyun.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>렛어스고 2022 여름 후기</title>
        <link>https://korjaeyoungyun.github.io/p/%EB%A0%9B%EC%96%B4%EC%8A%A4%EA%B3%A0-2022-%EC%97%AC%EB%A6%84-%ED%9B%84%EA%B8%B0/</link>
        <pubDate>Sun, 24 Jul 2022 10:10:45 +0900</pubDate>
        
        <guid>https://korjaeyoungyun.github.io/p/%EB%A0%9B%EC%96%B4%EC%8A%A4%EA%B3%A0-2022-%EC%97%AC%EB%A6%84-%ED%9B%84%EA%B8%B0/</guid>
        <description>&lt;img src="https://korjaeyoungyun.github.io/p/%EB%A0%9B%EC%96%B4%EC%8A%A4%EA%B3%A0-2022-%EC%97%AC%EB%A6%84-%ED%9B%84%EA%B8%B0/thumbnail.png" alt="Featured image of post 렛어스고 2022 여름 후기" /&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://let-us-go-2022-summer.vercel.app/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;렛어스고 2022 여름 행사&lt;/a&gt;에 갔다왔습니다.&lt;/p&gt;
&lt;p&gt;회사에서 알림까지 맞춰가면서 참가 신청을 했었는데, 운좋게 선착순에 들게되어 가게 되었네요.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;me.png&#34;
         alt=&#34;접니다&#34; width=&#34;250&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;접니다&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;행사는 ssg의 장소협찬으로 역삼 센터필드 ssg 사무실에서 하게되었습니다.&lt;br&gt;
아주 밝고 화사하게 잘 꾸며놨더라구요.&lt;/p&gt;
&lt;p&gt;저는 회사 동료 한분이랑 같이 입장했는데, 이미 많은 분들이 와서 이야기 나누고, 착석하여 준비를 하고 계셨습니다.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;ssg.png&#34;
         alt=&#34;실제로 보면 더 환하고 이쁩니다&#34; width=&#34;600&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;실제로 보면 더 환하고 이쁩니다&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&#34;세션&#34;&gt;세션&lt;/h3&gt;
&lt;p&gt;다양한 분들이 다양한 주제로 발표를 해주셨습니다.&lt;/p&gt;
&lt;p&gt;경험이 꽤 되신 분들부터, 경험이 오래되지 않으신 분들, 그리고 포항공대의 애플 아카데미에 계신 분도 계셨죠.&lt;/p&gt;
&lt;p&gt;놀라웠던 점은 이러한 자리에서 발표를 한다는 것은 정말 큰 부담이고 고수만 할 수 있다는 생각을 하고 있었는데&lt;br&gt;
주니어 분들도 자신만의 주제와 인사이트를 가지고 발표를 해주셨습니다.&lt;br&gt;
그걸 보면서 용기에 반했고 또한 많은 것을 배울 수 있었습니다.&lt;/p&gt;
&lt;p&gt;기억에 남는 것은 핫 리로딩과 DocC입니다.&lt;/p&gt;
&lt;p&gt;핫 리로딩은 SwiftUI의 프리뷰처럼 따로 빌드를 하지 않고 실시간으로 시뮬에서 수정사항을 볼 수 있는 기술이었습니다.&lt;br&gt;
이것을 적용하면 개발하면서 시간 낭비를 줄일 수 있기 때문에 관심있게 보았습니다.&lt;/p&gt;
&lt;p&gt;DocC는 애플의 공식문서 처럼 문서화를 할 수 있는 기술이었는데&lt;br&gt;
주석형태로 작성하여 DocC를 통해서 컴파일한다는 점도 흥미로웠고, 애플 문서처럼 구조화, 코드 스펙에 대한 내용이 자동으로 생성된다는 점이 매우 흥미로웠습니다.&lt;/p&gt;
&lt;h3 id=&#34;네트워킹&#34;&gt;네트워킹&lt;/h3&gt;
&lt;p&gt;세션 절반이 끝나고 네트워킹 시간이 있었습니다.&lt;br&gt;
이때, 자유롭게 돌아다니면서 다른 사람들과 인사를 할 수 있었는데&lt;br&gt;
특히 발표자분들 주변에는 많은 사람들이 모여서 발표 주제에 대해서 심도 있는 대화를 나누고 계셨습니다.&lt;/p&gt;
&lt;p&gt;저는 민소네님 곁에서 tuist에 대한 대화를 구경(?)했습니다.&lt;br&gt;
많은 분들이 tuist를 사용하시는 건지 질문이 많았습니다.&lt;br&gt;
기억에 남는 내용은 tuist는 프로젝트를 구성하는 도구일 뿐이며, 프로젝트 설정과 구성에 따라 SPM과 tuist등 도구를 잘 골라서 사용하면 된다는 것이었습니다.&lt;/p&gt;
&lt;p&gt;그 후, 야곰 테크 코스를 같이 들었던 분들을 만나 그 분들과 재미있게 이야기를 나누었습니다.&lt;br&gt;
오프라인에서 만난 것은 처음이라 어색했지만 서로 근황을 얘기하면서 친해질 수 있었습니다.&lt;/p&gt;
&lt;p&gt;아쉬웠던 점은 다들 명함을 주고받으면서 인사를 했는데 저는 명함을 가져가지 않아서 드리지 못했습니다. 😭&lt;/p&gt;
&lt;h3 id=&#34;재밌었습니다&#34;&gt;재밌었습니다!&lt;/h3&gt;
&lt;p&gt;코로나 때문에 렛어스고가 2년동안 안하게 되면서 저에게는 첫 렛어스고 행사였습니다.&lt;br&gt;
영상으로만 보면서 iOS 개발자의 꿈을 키웠었는데, 이제는 개발자로서 참가하게되니 더욱 뜻깊었습니다.&lt;/p&gt;
&lt;p&gt;앞으로도 렛어스고 행사에 계속 참가하면서 저도 한국 iOS 생태계에 기여할 수 있었으면 좋겠습니다.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;all.JPG&#34; width=&#34;800&#34;/&gt;
&lt;/figure&gt;

</description>
        </item>
        <item>
        <title>Riiid에서의 수습기간 회고</title>
        <link>https://korjaeyoungyun.github.io/p/riiid%EC%97%90%EC%84%9C%EC%9D%98-%EC%88%98%EC%8A%B5%EA%B8%B0%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
        <pubDate>Sat, 02 Jul 2022 20:53:18 +0900</pubDate>
        
        <guid>https://korjaeyoungyun.github.io/p/riiid%EC%97%90%EC%84%9C%EC%9D%98-%EC%88%98%EC%8A%B5%EA%B8%B0%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
        <description>&lt;p&gt;처음 뤼이드에 찾아갔을 때, 사무실이 정말 멋졌습니다.&lt;br&gt;
잘 꾸며지고 있을거 다 있는 사무실을 보면서 여기서 일하는 내 모습을 상상했었죠.&lt;br&gt;
그런 제가 뤼이드에 입사한지도 벌써 3개월이 흘렀습니다.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;me.png&#34;
         alt=&#34;네 접니다&#34; width=&#34;300&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;네 접니다&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;기존의 환경에서 벗어나 새로운 환경에 들어가게 되니 처음에는 많이 낯설더군요.&lt;br&gt;
새로운 멋진 동료들과 일하면서 짧지만 3개월동안 많은 것을 보고 느낄 수 있었습니다.&lt;/p&gt;
&lt;p&gt;지난 일들을 돌아보면서 더욱 더 발전해나가고, 미래에 다시 돌아볼 수 있도록 뤼이드에서의 새로운 경험들을 정리합니다.&lt;/p&gt;
&lt;h3 id=&#34;코드-구현을-넘어서-&#34;&gt;코드 구현을 넘어서 🚀&lt;/h3&gt;
&lt;p&gt;제가 가장 크게 변한 부분입니다.&lt;/p&gt;
&lt;p&gt;첫 현업에 들어가고 나서 일년여동안에는 코드에 대해 집중했습니다.&lt;br&gt;
어떻게하면 더 깔끔한 코드를 짤 수 있는지, 어떻게 기능을 구현해야 하는지에 대해서 고민하고 공부하던 시기였죠.&lt;br&gt;
올해도 여전히 공부할 것은 많고 코딩에 대해서 발전시켜야하지만 다른 부분에 대해서도 시야가 트이기 시작했습니다.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;books.png&#34;
         alt=&#34;최근에 빌려본 책들&#34; width=&#34;500&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;최근에 빌려본 책들&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;개발적으로는 CI/CD, 자동화 등등 Xcode밖에서도 해야할 것들이 많더라구요.&lt;br&gt;
언젠간 이러한 것들도 자유자재로 다룰 수 있었으면 좋겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;dxdevloper-experience-devreldeveloper-relations-팀의-존재-&#34;&gt;DX(Devloper Experience), DevRel(Developer Relations) 팀의 존재 🙏&lt;/h3&gt;
&lt;p&gt;DX 팀에서는 개발에 도움이 될 수 있는 부분에 대한 도구들을 편리하게 만들어 제공해줍니다.&lt;br&gt;
한마디로 개발자들을 위한 개발자들이라고 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;DevRel팀은 개발 관련 행사를 주최하는 등 회사 안팎으로 개발자들이 소통하고 교류할 수 있게 도움을 줍니다.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;wwdc.JPG&#34;
         alt=&#34;DevRel팀의 도움으로 외부인들을 초청한 wwdc 같이 보기 행사도 했었습니다&#34; width=&#34;500&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;DevRel팀의 도움으로 외부인들을 초청한 wwdc 같이 보기 행사도 했었습니다&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;정말 없어서는 안되는 소중한 조직입니다.&lt;/p&gt;
&lt;h3 id=&#34;회고-및-교류-&#34;&gt;회고 및 교류 🧐&lt;/h3&gt;
&lt;p&gt;이 글을 쓰게 된 계기 역시 회고 문화를 경험하면서 생기게 되었습니다.&lt;/p&gt;
&lt;p&gt;제품 팀과의 회고, iOS 개발자들끼리의 회고를 통해 잘한 것과 문제점들을 공유하며&lt;br&gt;
서로 칭찬하고, 개선할 방향들을 탐색해나가는 일들이 주기적으로, 자주 일어나고 있습니다.&lt;br&gt;
다양한 시각과 의견들을 자유롭게 나누는 모습이 처음에 굉장히 인상적이었습니다.&lt;/p&gt;
&lt;p&gt;또한 기술 교류시간이 있어서 iOS 개발자들 끼리 모여서 신기술을 공부하고, 해결하기 어려웠던 문제들을 공유하며 조언을 구합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;지난 3개월을 돌아보니 회사에 적응하면서 다양한 것들을 느끼고 있음을 새삼 깨닫습니다.&lt;/p&gt;
&lt;p&gt;회사에서 개발에 더욱 집중하기 위해 많은 것들에 힘쓰는 것을 보면서 더욱 더 책임감있게 일을 해야겠다는 생각이 듭니다.&lt;br&gt;
또한 아직 배워야할 것들이 많아 앞으로 열심히 공부하며 나 자신도 발전시켜나가야 할 것 같습니다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>alignmentGuide 활용하기</title>
        <link>https://korjaeyoungyun.github.io/p/alignmentguide-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
        <pubDate>Thu, 02 Jun 2022 19:58:34 +0900</pubDate>
        
        <guid>https://korjaeyoungyun.github.io/p/alignmentguide-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
        <description>&lt;img src="https://korjaeyoungyun.github.io/p/alignmentguide-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0/thumbnail.jpg" alt="Featured image of post alignmentGuide 활용하기" /&gt;&lt;p&gt;SwiftUI에서는 alignmentGuide 메소드를 통해 정렬 기준을 커스터마이징할 수 있습니다.&lt;br&gt;
이를 통해서 우리는 단순히 제공되는 정렬이 아닌, 우리만의 기준으로 뷰들을 정렬시킬 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;func-alignmentguideg-computevlue---some-view&#34;&gt;func alignmentGuide(g, computeVlue) -&amp;gt; some View&lt;/h3&gt;
&lt;p&gt;alignmentGuide 메소드는 &lt;strong&gt;g&lt;/strong&gt;와 &lt;strong&gt;computeValue&lt;/strong&gt; 두 가지 인자를 받습니다.&lt;/p&gt;
&lt;p&gt;g는 HorizontalAlignment 또는 VerticalAlignment인데, 해당 Alignment에 대한 정렬 기준을 나타낸다는 뜻입니다.&lt;br&gt;
예를들어 g에 HorizontalAlignment.leading를 주게 되면 HorizontalAlignment.leading에 대한 기준을 alignmentGuide를 통해 커스텀한다는 뜻입니다.&lt;/p&gt;
&lt;p&gt;두 번째 인자인 computeValue는 (ViewDimensions) -&amp;gt; CGFloat 클로저 입니다. 이 클로저는 정렬에 사용할 offset을 계산합니다.&lt;br&gt;
클로저에서는 ViewDimensions를 주는데,  ViewDimensions는 해당 뷰의 크기와 alignmentGuide들을 제공합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결과적으로 computeValue에서 계산된 offset이 g에 적용되어 g에 대한 정렬이 바뀌게 되는 것입니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;예제---top-정렬을-center-정렬로-바꾸기&#34;&gt;예제 - top 정렬을 center 정렬로 바꾸기&lt;/h3&gt;
&lt;p&gt;예제를 통해서 alignmentGuide 활용법에 대해서 알아보도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;우리는 책의 목록을 나타내고자 합니다.
책의 목록은 아래와 같이 단순하게 책 제목과 책 제목 왼쪽에 점이 붙어 있는 형태입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;책1&lt;/li&gt;
&lt;li&gt;책2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이를 구현하기 위해서 생각나는대로 코드를 작성해봅니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;BookItemView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;View&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;some&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;View&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;HStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;alignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;systemName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;circle.fill&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resizable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

      &lt;span class=&#34;n&#34;&gt;Text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위 코드처럼 BookItemView를 만들고 이를 List안에 ForEach를 통해서 책의 목록을 구현하였습니다.&lt;br&gt;
하지만 여기에는 문제가 있습니다.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;wrong1.png&#34;
         alt=&#34;정렬이 맞지 않는 목록 아이템&#34; width=&#34;250&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;정렬이 맞지 않는 목록 아이템&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;위 이미지처럼 동그라미 아이콘과 책 제목의 정렬이 맞지 않는 것입니다.&lt;/p&gt;
&lt;h4 id=&#34;top-padding으로-해결하기&#34;&gt;top padding으로 해결하기&lt;/h4&gt;
&lt;p&gt;이를 해결하기 위해 이미지에 필요한 top padding 계산해서 넣어주면 해결됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;some&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;View&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;HStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;alignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;systemName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;circle.fill&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resizable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;padding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 정렬을 맞추기 위한 top padding&lt;/span&gt;

      &lt;span class=&#34;n&#34;&gt;Text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure&gt;&lt;img src=&#34;good.png&#34;
         alt=&#34;top padding을 줘서 정렬된 목록 아이템&#34; width=&#34;250&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;top padding을 줘서 정렬된 목록 아이템&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;이렇게 하면 정렬이 잘 되지만 이미지나 텍스트의 크기가 변할 경우, 패딩 또한 다시 계산해서 바꿔줘야합니다.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;wrong2.png&#34;
         alt=&#34;top padding을 줬지만 아이콘 크기가 바뀌어 정렬이 맞지 않는 목록 아이템&#34; width=&#34;250&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;top padding을 줬지만 아이콘 크기가 바뀌어 정렬이 맞지 않는 목록 아이템&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&#34;alignmentguide로-해결하기&#34;&gt;alignmentGuide로 해결하기&lt;/h4&gt;
&lt;p&gt;alignmentGuide를 사용하면 이런 상황을 깔끔하게 해결할 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;some&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;View&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;HStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;alignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;systemName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;circle.fill&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resizable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;alignmentGuide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;VerticalAlignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;viewDimensions&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 정렬을 맞추기 위한 alignmentGuide&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;viewDimensions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;Text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;alignmentGuide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;VerticalAlignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;viewDimensions&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 정렬을 맞추기 위한 alignmentGuide&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;viewDimensions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위 코드에서는 Image와 Text에 alignmentGuide를 주었습니다.&lt;/p&gt;
&lt;p&gt;alignmentGuide의 첫 번째 인자인 VerticalAlignment.top은 말 그대로 VerticalAlignment.top 정렬에 대한 기준을 정하겠다는 것을 뜻합니다.&lt;/p&gt;
&lt;p&gt;두 번째 인자에서 그 기준에 대한 offset을 계산하는데 여기서는 해당 뷰의 절반만큼을 offset으로 주었습니다.&lt;br&gt;
top에서 뷰 높이의 절반만큼 더하면 뷰의 중간이 되겠죠.&lt;br&gt;
따라서 우리가 원하는 중간 정렬이 됩니다. 이는 뷰의 크기가 변하더라도 그에 맞게 계산되어 앞의 문제를 해결합니다.&lt;/p&gt;
&lt;h4 id=&#34;더-나아가서&#34;&gt;더 나아가서&lt;/h4&gt;
&lt;p&gt;사실 중간정렬은 alignment를 top이 아닌, center로 주면 간단하게 구현가능합니다. 😅&lt;br&gt;
하지만 이해를 위해 위 예제를 만들어 보았습니다.&lt;/p&gt;
&lt;p&gt;이해에 도움이 되었으면하는 바람이며, 이를 통해서 나만의 커스텀 정렬을 수행해보시길 바랍니다.&lt;br&gt;
예를들어, 아이콘과 여러줄의 Text의 첫 번째 줄을 가운데 정렬해보시는 것들도 alignmentGuide를 사용하면 구현할 수 있습니다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>코드 리뷰를 잘하는 법</title>
        <link>https://korjaeyoungyun.github.io/p/%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0%EB%A5%BC-%EC%9E%98%ED%95%98%EB%8A%94-%EB%B2%95/</link>
        <pubDate>Fri, 29 Apr 2022 23:18:40 +0900</pubDate>
        
        <guid>https://korjaeyoungyun.github.io/p/%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0%EB%A5%BC-%EC%9E%98%ED%95%98%EB%8A%94-%EB%B2%95/</guid>
        <description>&lt;img src="https://korjaeyoungyun.github.io/p/%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0%EB%A5%BC-%EC%9E%98%ED%95%98%EB%8A%94-%EB%B2%95/thumbnail.jpg" alt="Featured image of post 코드 리뷰를 잘하는 법" /&gt;&lt;p&gt;코드 리뷰를 잘하고 싶어서 자료들을 찾아보면서 알게된 것들을 정리합니다.&lt;/p&gt;
&lt;h4 id=&#34;코드리뷰를-왜-신경써야-하는가&#34;&gt;코드 리뷰를 왜 신경써야 하는가?&lt;/h4&gt;
&lt;p&gt;중요한 것은 코드 리뷰 역시 코딩과 마찬가지로 우리가 해야할 &amp;lsquo;일&amp;rsquo;이라고 생각하는 것입니다.&lt;/p&gt;
&lt;p&gt;간혹, 코드 리뷰를 그저 하나의 여가 시간(?)과 같이 생각하는 경우가 있는데&lt;br&gt;
작업 시간의 일부를 할당해서 일로써 수행을 해야 합니다.&lt;br&gt;
그래야 체계적이고 진지하게 리뷰를 주고 받을 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한 코드 리뷰를 통해서 다양한 시각과 의견을 주고 받을 수 있으며&lt;br&gt;
나 혼자서는 찾지 못했던 버그나 개선점들을 얻을 수 있고 설명하는 능력을 기를 수 있습니다.&lt;br&gt;
이를 통해서 서로 지식과 소프트 스킬을 향상 시킬 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;요청자requester&#34;&gt;요청자(Requester)&lt;/h3&gt;
&lt;h4 id=&#34;코드-리뷰를-요청하기-전-잘-정리하기&#34;&gt;코드 리뷰를 요청하기 전 잘 정리하기&lt;/h4&gt;
&lt;p&gt;리뷰를 받을 코드의 문맥을 가장 잘 파악하고 있는 사람은 리뷰 요청자 입니다.&lt;/p&gt;
&lt;p&gt;요청자가 미리 리뷰 내용과 의도를 잘 서술하면 그만큼 리뷰어의 시간을 절약할 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;작게나누어서-요청하기&#34;&gt;작게 나누어서 요청하기&lt;/h4&gt;
&lt;p&gt;너무 많은 코드를 한번에 요청하면 리뷰어에게 많은 부담과 시간 소모를 주게 됩니다.&lt;br&gt;
또한 코드를 이해하기도 점점 힘들어지기 때문에 작은 단위로 리뷰받는 것이 좋습니다.&lt;/p&gt;
&lt;p&gt;보통 정량적으로는 200 라인 정도를 이야기하고, 정성적으로는 의미있는 작업 덩어리를 이야기 합니다.&lt;/p&gt;
&lt;h3 id=&#34;리뷰어reviewer&#34;&gt;리뷰어(Reviewer)&lt;/h3&gt;
&lt;h4 id=&#34;리뷰는최대한-빠르게&#34;&gt;리뷰는 최대한 빠르게&lt;/h4&gt;
&lt;p&gt;요청자가 다음에 할 작업이 코드 리뷰가 완료되어야 진행되는 경우도 있고&lt;br&gt;
요청자가 여러가지를 신경쓰게 하지 않기 위해 리뷰는(응답이라도) 최대한 빠르게 해줍니다.&lt;/p&gt;
&lt;p&gt;가급적 하루를 넘기지 않으며, 병목 해소를 위해 하루를 넘기면 리뷰를 패스한다는 팀 간의 약속을 정할 수도 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;왜안좋은-부분만-남기죠&#34;&gt;왜 안좋은 부분만 남기죠?&lt;/h4&gt;
&lt;p&gt;우리는 보통 피드백을 남길 때 코멘트를 하고, 잘한 부분은 그냥 보고 넘어갑니다.&lt;/p&gt;
&lt;p&gt;잘한 부분이 보이면 가감없이 칭찬해줍시다.&lt;/p&gt;
&lt;p&gt;서로간의 신뢰가 향상되는 것을 느낄 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;완벽할-수는-없습니다&#34;&gt;완벽할 수는 없습니다&lt;/h4&gt;
&lt;p&gt;리뷰하는 코드가 내 마음에 들지 않을 수 있습니다.&lt;br&gt;
피드백을 남기고 토론을 할 수 있지만 너무 완강한 의견 제시는 서로를 피곤하게 합니다.&lt;/p&gt;
&lt;p&gt;어느정도 문제가 없을 것 같다면 수용합시다.&lt;/p&gt;
&lt;p&gt;다만, 코드에 분명한 문제가 있는데 요청자가 고집을 부린다면 다른 사람(더 잘하는 사람)이 리뷰에 참여하게 하는 것이 좋습니다.&lt;/p&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://google.github.io/eng-practices/review/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;구글 코드 리뷰 가이드&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://youtu.be/ssDMIcPBqUE&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;우아한 형제들에서 코드리뷰를 주제로 한 테크 세미나&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>야곰 빗썸 테크 캠프 1기를 마치며</title>
        <link>https://korjaeyoungyun.github.io/p/%EC%95%BC%EA%B3%B0-%EB%B9%97%EC%8D%B8-%ED%85%8C%ED%81%AC-%EC%BA%A0%ED%94%84-1%EA%B8%B0%EB%A5%BC-%EB%A7%88%EC%B9%98%EB%A9%B0/</link>
        <pubDate>Thu, 17 Mar 2022 22:02:57 +0900</pubDate>
        
        <guid>https://korjaeyoungyun.github.io/p/%EC%95%BC%EA%B3%B0-%EB%B9%97%EC%8D%B8-%ED%85%8C%ED%81%AC-%EC%BA%A0%ED%94%84-1%EA%B8%B0%EB%A5%BC-%EB%A7%88%EC%B9%98%EB%A9%B0/</guid>
        <description>&lt;img src="https://korjaeyoungyun.github.io/p/%EC%95%BC%EA%B3%B0-%EB%B9%97%EC%8D%B8-%ED%85%8C%ED%81%AC-%EC%BA%A0%ED%94%84-1%EA%B8%B0%EB%A5%BC-%EB%A7%88%EC%B9%98%EB%A9%B0/thumbnail.jpg" alt="Featured image of post 야곰 빗썸 테크 캠프 1기를 마치며" /&gt;&lt;p&gt;iOS 개발을 공부하신 분이라면 다들 스위프트 프로그래밍이라는 책을 보신 기억이 있으실 것 입니다.&lt;br&gt;
저는 야곰이라는 닉네임을 들으면 그 책이 생각나면서 처음 iOS 개발을 공부하던 것이 생각납니다.&lt;/p&gt;
&lt;p&gt;이번에 그 야곰이 운영하는 &lt;a class=&#34;link&#34; href=&#34;https://www.yagom-academy.kr/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;야곰 아카데미&lt;/a&gt;에서 빗썸의 지원을 받아 테크 캠프 1기를 진행하였는데&lt;br&gt;
제가 참가하고 수료하게 되었습니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 테크 캠프에서 경험하고 느꼈던 것들에 대해서 이야기 해보도록 하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;지원-과정&#34;&gt;지원 과정&lt;/h3&gt;
&lt;p&gt;지원할 때 특별히 무언가를 제출하거나 자격이 요구되지는 않았습니다.&lt;/p&gt;
&lt;p&gt;다만, 사전 과제를 진행하여 선발 과정을 거쳤습니다.&lt;br&gt;
사전 과제 기간이 설 연휴였는데, 연휴니까 시간이 있겠군 하고 시작했다가 마지막 즈음엔 &lt;del&gt;남들 다 쉬는데 이게 뭐하는 짓이지&lt;/del&gt; 하는 생각이 든 기억이 납니다.&lt;br&gt;
그래도 선발이 되기 위해 최선을 다해서 과제를 수행하였습니다.&lt;/p&gt;
&lt;h3 id=&#34;4주간의-과정&#34;&gt;4주간의 과정&lt;/h3&gt;
&lt;p&gt;교육은 iOS 개발과 관련된 내용들에 대해 진행하였습니다.&lt;br&gt;
평일 저녁~밤 시간대에 교육이 진행되었는데, 매일 퇴근하고 수업을 들으려니까 상당히 힘들었습니다(꾸벅꾸벅 졸기도 했습니다 ㅠ).&lt;/p&gt;
&lt;p&gt;교육 내용은 매번 다양한 주제로 상당히 흥미로웠습니다.&lt;br&gt;
자세한 교육 내용은 &lt;a class=&#34;link&#34; href=&#34;https://www.yagom-academy.kr/bithumb-tech-camp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;야곰 아카데미 캠프 사이트&lt;/a&gt;를 찾아보시기 바랍니다.&lt;/p&gt;
&lt;p&gt;한정된 시간 내에서 다양한 부분들을 교육하느라 각 주제들을 깊게 다루진 않았지만, 모르는 부분이 상당히 많이 있었고 앞으로 공부하면서 채워 나가야 할 키워드들에 대해 알게 되었습니다.&lt;/p&gt;
&lt;p&gt;또한 단순히 듣기만 하는 강의가 아닌, 여러 사람과 함께 활동하면서 논의도 해보고 구현도 해보는 실습들을 많이 진행하여 서로의 생각과 지식을 공유할 수 있었습니다.&lt;/p&gt;
&lt;h3 id=&#34;팀-프로젝트&#34;&gt;팀 프로젝트&lt;/h3&gt;
&lt;p&gt;강의 뿐만 아니라, 팀 프로젝트도 수행했습니다 (다들 고생하셨습니다 ㅠ).&lt;/p&gt;
&lt;p&gt;팀 프로젝트는 팀원과 멘토로 구성되어 진행하였는데,&lt;br&gt;
단순 구현만 하는 것이 아닌 팀원 간의 규칙, 코딩 컨벤션과 같은 협업에 있어 필요한 다양한 것들을 서로 논의하고 발전시켜나가는 과정이 있었습니다.&lt;/p&gt;
&lt;p&gt;고민되는 부분이 있을 때에는 언제든지 팀원들과 멘토에게 조언을 구하고 토론하며 방향을 잡아 나갈 수 있었기 때문에 모르는 부분에 대해서 겁내지 않아도 되었습니다.&lt;/p&gt;
&lt;h3 id=&#34;꼭-해보세요&#34;&gt;꼭 해보세요&lt;/h3&gt;
&lt;p&gt;평소 혼자 공부를 하다가 이렇게 다른 사람들과 같이 공부하게 된 경험은 처음인 것 같습니다.&lt;/p&gt;
&lt;p&gt;처음에는 강의에 대해서만 생각하고 강의를 들으려고 지원하게 되었지만,&lt;br&gt;
막상 끝나고 나니 사람들과 같이 진행했던 것들이 기억에 많이 남습니다.&lt;br&gt;
같은 분야의 사람들과 iOS에 대해 서로 이야기하고 공부하니 정말 재미있었고 좋은 동기부여가 되었습니다.&lt;/p&gt;
&lt;p&gt;저처럼 주로 혼자 공부해오신 분이라면 이러한 활동을 한번은 해보시는 것을 적극 추천드립니다👍&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Skeletonview 적용하기</title>
        <link>https://korjaeyoungyun.github.io/p/skeletonview-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
        <pubDate>Sun, 23 Jan 2022 16:35:40 +0900</pubDate>
        
        <guid>https://korjaeyoungyun.github.io/p/skeletonview-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
        <description>&lt;h3 id=&#34;스켈레톤-뷰-구성-하기&#34;&gt;스켈레톤 뷰 구성 하기&lt;/h3&gt;
&lt;p&gt;스켈레톤 뷰는 기존 뷰에 isSkeletonable을 통해 별다른 추가 작업없이 스켈레톤 스크린을 구현할 수 있게 해줍니다.&lt;br&gt;
하지만 스켈레톤 뷰를 몇 번 사용해보니 우리가 정학히 원하는 모양을 잡기 위해서 기존의 뷰를 그대로 활용하기가 애매해지는 부분이 있었습니다.&lt;br&gt;
기존의 뷰의 크기가 고정되어 있지 않고 동적인 경우, 스켈레톤 뷰를 위해서 스켈레톤을 띄우는 동안에는 원하는 크기로 고정을 시켜주어야 합니다.&lt;/p&gt;
&lt;p&gt;예를 들어, width를 잡지 않고 사용하는 UILabel의 경우, text 크기에 따라서 width가 정해지게 됩니다.&lt;br&gt;
이 label에 스켈레톤을 적용하려면, width를 잡아주거나, 일정 크기만큼의 dummy text를 넣어주어야 합니다.&lt;br&gt;
이는 내가 원하지 않은 설계가 되거나, 가독성이 떨어지는 코드가 될 가능성이 있습니다.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;ex1.png&#34;
         alt=&#34;기존 뷰&#34; width=&#34;250&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;기존 뷰&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;다음과 같은 기존 뷰에 스켈레톤 뷰를 적용해보겠습니다.&lt;br&gt;
해당 뷰는 제목과 설명을 보여주는 두 개의 UILabel로 구성되어 있습니다.&lt;br&gt;
또한, 레이블에 텍스트는 데이터가 로딩 된 후 채워진다고 가정합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;titleLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isSkeletonable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;descriptionLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isSkeletonable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위와 같이 스켈레톤을 적용해주고 showSkeleton()을 호출해주면 데이터가 없는 상태에서 두 레이블의 텍스트가 비어있고, 텍스트가 비어있으니까 width가 0이기 때문에 아무것도 뜨지 않습니다.&lt;/p&gt;
&lt;p&gt;이를 해결하기 위해 먼저, 레이블의 너비를 고정시켜보겠습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;titleLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;widthAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constraint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalToConstant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;300&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;descriptionLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;widthAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constraint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;widthAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;40&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;descriptionLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;heightAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constraint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalToConstant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;300&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이런 방식으로 데이터가 들어오기 전에 스켈레톤 뷰를 구성해 줄 수 있지만, 이렇게 되면 데이터가 들어온 후 레이아웃 제약을 바꿔주어야하므로 사용하기 불편합니다.&lt;/p&gt;
&lt;p&gt;다른 방법으로는 레이블에 가짜 데이터를 채워서 너비가 잡혀있게 하는 것인데 이는 코드가 보기에 깔끔하지 않습니다.&lt;/p&gt;
&lt;h3 id=&#34;분리해서-관리하기&#34;&gt;분리해서 관리하기&lt;/h3&gt;
&lt;p&gt;마지막으로 이를 해결하기 위해 기존 뷰와 같은 모양과 레이아웃을 가진 뷰를 만들어 이를 스켈레톤 시 보여줬다가 스켈레톤이 끄면 숨겨버리는 방식을 사용하겠습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MySkeletonView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UIView&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;titleView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UIView&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;view&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UIView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isSkeletonable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;translatesAutoresizingMaskIntoConstraints&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;view&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
  
  &lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;descriptionView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UIView&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;view&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UIView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isSkeletonable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;translatesAutoresizingMaskIntoConstraints&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;view&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
  
  &lt;span class=&#34;kd&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
    
    &lt;span class=&#34;n&#34;&gt;NSLayoutConstraint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;activate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;titleView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;topAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constraint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;topAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;titleView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;leadingAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constraint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;leadingAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;titleView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;widthAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constraint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalToConstant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;titleView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;heightAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constraint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalToConstant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;40&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
      
      &lt;span class=&#34;n&#34;&gt;descriptionView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;topAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constraint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;titleView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bottomAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;40&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;descriptionView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;leadingAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constraint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;leadingAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;descriptionView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;trailingAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constraint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;trailingAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;descriptionView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;heightAnchor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constraint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalToConstant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;300&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;새로 만들어서 분리한 스켈레톤 뷰입니다. 기존 뷰의 껍데기만 흉내내고 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;showMySkeleton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;skeletonView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isHidden&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;skeletonView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;showSkeleton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hideMySkeleton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;skeletonView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hideSkeleton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;skeletonView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isHidden&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이를 기존 뷰에서 사용하여 스켈레톤을 띄웁니다.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;ex2.gif&#34;
         alt=&#34;스켈레톤 뷰 적용된 모습&#34; width=&#34;250&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;스켈레톤 뷰 적용된 모습&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&#34;정리&#34;&gt;정리&lt;/h3&gt;
&lt;p&gt;기존 뷰와 스켈레톤용 뷰를 분리하여 구성하면 UI 디자인이 바뀔 때마다 기존 뷰와 스켈레톤 용 뷰 두 개를 수정해야한다는 단점이 있지만, 스켈레톤 용 뷰가  깔끔하고 단순해져서 관리하기가 더 편하다는 장점이 있습니다.&lt;/p&gt;
&lt;p&gt;cell 역시 이런식으로 스켈레톤용을 따로 만들어서 사용하면 관리하기가 수월해집니다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>UX를 향상시켜주는 SkeletonView</title>
        <link>https://korjaeyoungyun.github.io/p/ux%EB%A5%BC-%ED%96%A5%EC%83%81%EC%8B%9C%EC%BC%9C%EC%A3%BC%EB%8A%94-skeletonview/</link>
        <pubDate>Sun, 16 Jan 2022 17:57:18 +0900</pubDate>
        
        <guid>https://korjaeyoungyun.github.io/p/ux%EB%A5%BC-%ED%96%A5%EC%83%81%EC%8B%9C%EC%BC%9C%EC%A3%BC%EB%8A%94-skeletonview/</guid>
        <description>&lt;p&gt;네트워크로 데이터를 받아오는 작업과 같이 시간이 오래걸리고, 언제 끝날지 모르는 작업들을 처리할 때, 그리고 그 작업의 결과를 화면에 보여줘야 할때 애플리케이션에서는 작업 진행 중이라는 것을 사용자에게 알려줌으로서 사용자가 작업이 완료될 때까지 기다릴 수 있게끔 유도합니다.&lt;/p&gt;
&lt;p&gt;단순히 빙글빙글 도는 인디케이터부터, 퍼센티지를 통해 어느정도 작업이 진행되었는지를 알려주는 progress bar등 다양한 방식으로 앱에서는 사용자 경험을 향상시키고자 노력합니다.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;iosbasicloading.gif&#34;
         alt=&#34;iOS 기본 로딩&#34; width=&#34;250&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;iOS 기본 로딩&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;이번 글에서는 그 중에서도 직관적으로 어떤 컨텐츠가 로딩되고 있는지를 표현할 수 있는 스켈레톤 스크린과 그걸 iOS에서 구현한 SkeletonView라는 라이브러리에 대해서 알아보겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;skeleton-screen-이란&#34;&gt;Skeleton Screen 이란?&lt;/h3&gt;
&lt;p&gt;스켈레톤 스크린이란 화면의 레이아웃과 모양에 유사하게 나오는 로딩입니다.&lt;br&gt;
그렇기 때문에 사용자가 앞으로 나올 화면을 예상할 수 있고, 사용자는 로딩이 더욱 실시간같고 빠르게 느껴지게 됩니다.&lt;/p&gt;
&lt;p&gt;유튜브, 페이스북등 많은 웹, 모바일 애플리케이션에서 이를 통해 사용자 경험을 증대시키고 있습니다.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;youtubeskeleton.PNG&#34;
         alt=&#34;유튜브 스켈레톤 화면&#34; width=&#34;250&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;유튜브 스켈레톤 화면&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&#34;skeleton-view&#34;&gt;Skeleton View&lt;/h3&gt;
&lt;p&gt;iOS 에서는 &lt;a class=&#34;link&#34; href=&#34;https://github.com/Juanpe/SkeletonView&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SkeletonView&lt;/a&gt; 라는 라이브러리를 사용하면 손쉽게 스켈레톤 스크린을 구현할 수 있습니다.&lt;/p&gt;
&lt;p&gt;스켈레톤 뷰는 UIView의 extension을 통해 기능을 제공합니다.&lt;br&gt;
스켈레톤 뷰를 사용하는 방법은 기본적으로 다음과 같습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isSkeletonable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;을 통해 내가 원하는 뷰를 스켈레톤 뷰로 띄울 수 있게 설정할 수 있습니다.&lt;br&gt;
그 다음 아래 코드로 스켈레톤을 켜고 끌 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;showSkeleton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hideSkeleton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;추가적으로 스켈레톤의 모양, 타이밍, 애니메이션등 다양한 설정을 해줄 수 있는데 이는 &lt;a class=&#34;link&#34; href=&#34;https://github.com/Juanpe/SkeletonView&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;공식문서&lt;/a&gt; 에서 확인해보시기 바랍니다.&lt;/p&gt;
&lt;p&gt;한 가지 중요한 점은, showSkeleton 과 hideSkeleton을 할때&lt;br&gt;
해당 뷰의 하위 뷰들에게도 적용이 된다는 점입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Since &lt;code&gt;SkeletonView&lt;/code&gt; is recursive, and we want skeleton to be very efficient, we want to stop recursion as soon as possible. For this reason, you must set the container view as &lt;code&gt;Skeletonable&lt;/code&gt;, because Skeleton will stop looking for &lt;code&gt;skeletonable&lt;/code&gt; subviews as soon as a view is not Skeletonable, breaking then the recursion.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;공식 문서에 따르면, 스켈레톤 뷰는 하위 뷰들을 재귀적으로 탐색하면서 isSkeletonable이 true로 설정되어 있는 뷰들에게 모두 적용이 됩니다.&lt;br&gt;
따라서 하나의 화면에 여러 스켈레톤 뷰들을 구성해놓고 일일히 스켈레톤 뷰를 끄고 킬 필요 없이, 최상위 뷰에서부터 하위 뷰까지 isSkeletonable을 true로 설정해주고 스켈레톤을 켜고 끄면 모두 적용이 되게 됩니다.&lt;/p&gt;
&lt;p&gt;이러한 기본적인 요소들을 이해하셨다면 스켈레톤 뷰를 적용하는데에 큰 어려움을 없을 것입니다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>viewDidLoad에서 navigationController가 없는 경우?</title>
        <link>https://korjaeyoungyun.github.io/p/viewdidload%EC%97%90%EC%84%9C-navigationcontroller%EA%B0%80-%EC%97%86%EB%8A%94-%EA%B2%BD%EC%9A%B0/</link>
        <pubDate>Wed, 05 Jan 2022 20:02:57 +0900</pubDate>
        
        <guid>https://korjaeyoungyun.github.io/p/viewdidload%EC%97%90%EC%84%9C-navigationcontroller%EA%B0%80-%EC%97%86%EB%8A%94-%EA%B2%BD%EC%9A%B0/</guid>
        <description>&lt;p&gt;UIViewController의 viewDidLoad는 한번만 호출되기 때문에 이곳에서 View 설정과 같은 ViewController의 초기화 작업을 주로 합니다.&lt;/p&gt;
&lt;p&gt;navigationController 역시 viewDidLoad에서 자주 다뤄지는 프로퍼티입니다.&lt;br&gt;
viewDidLoad에서 아래와 같은 코드를 자주 사용해 보셨을 것 입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kr&#34;&gt;override&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;navigationController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;?.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setNavigationBarHidden&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;animated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;혹시 이런 상황에서 navigationController가 당연히 있을 것이라고 생각했는데, nil인 경우인 적이 있으신가요?&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;screenshot.png&#34; width=&#34;900&#34;/&gt;
&lt;/figure&gt;

&lt;p&gt;분명히 navigationController를 통해서 viewController를 띄웠고&lt;br&gt;
여태까지 위와 같이 viewDidLoad에서 navigationController에 접근하는 것은 문제가 없었는데,&lt;br&gt;
어떤 경우에서 문제가 발생하는걸까요?&lt;/p&gt;
&lt;p&gt;이 글에서는 이러한 상황이 왜 일어나는 지에 대해서 알아보도록 하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;viewdidload의-호출-시점&#34;&gt;viewDidLoad의 호출 시점&lt;/h3&gt;
&lt;p&gt;이런 상황은 viewDidLoad 호출되는 시점과 관련이 있습니다.&lt;/p&gt;
&lt;p&gt;공식문서를 살펴보면, viewDidLoad의 호출 시점에 대해서 이렇게 나와 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;This method is called after the view controller has loaded its view hierarchy into memory&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;뷰 컨트롤러의 뷰가 메모리에 로딩되었을 때 호출된다고 합니다.&lt;br&gt;
그럼 뷰는 언제 메모리에 로딩될까요?&lt;/p&gt;
&lt;p&gt;다음으로 loadView에 대한 공식 문서입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The view controller calls this method when its view property is requested but is currently nil.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;뷰 프로퍼티가 요청되었을 때 뷰가 없으면 뷰를 로딩한다고 나와 있습니다.&lt;br&gt;
이와 같이 우리가 ViewController가 띄워지기 전에 미리 해당 뷰컨의 view에 접근할 경우 viewDidLoad가 호출된다는 것을 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;상황에 대한 정확한 이해를 위해 코드를 통해 확인해보도록 하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;샘플-코드&#34;&gt;샘플 코드&lt;/h3&gt;
&lt;h5 id=&#34;일반적인-상황&#34;&gt;일반적인 상황&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;FirstViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UIViewController&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
  
  &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;moveToSecondView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;navigationController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;?.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pushViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SecondViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;animated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;SecondViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UIViewController&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kr&#34;&gt;override&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// do something with navigationController&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// navigationController != nil&lt;/span&gt;
    &lt;span class=&#34;kc&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;navigationController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위와 같이 일반적인 상황에서 우리는 뷰컨트롤러를 생성하고 바로 화면 전환을 합니다.&lt;br&gt;
그러면 화면 전환 전에는 두 번째 뷰컨트롤러의 view를 사용하지 않으니 viewDidLoad가 호출되지 않고 화면 전환될 때 호출되게 됩니다.&lt;br&gt;
화면 전환이 될 때에는 navigationController를 통해서 화면전환을 시켰으니 두 번째 뷰컨트롤러에서 navigationController에 아무 문제없이 접근할 수 있습니다.&lt;/p&gt;
&lt;p&gt;그럼 문제가 되는 다른 상황의 코드를 보겠습니다.&lt;/p&gt;
&lt;h5 id=&#34;navigationcontroller가-없는-상황&#34;&gt;navigationController가 없는 상황&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;FirstViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UIViewController&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;secondVC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SecondViewController&lt;/span&gt;
  
  &lt;span class=&#34;c1&#34;&gt;// this method is called before moveToSecondView()&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;configureSecondView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// do something with secondVC&amp;#39;s view&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;secondVC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  
  &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;moveToSecondView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;navigationController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;?.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pushViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SecondViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;animated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;SecondViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UIViewController&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kr&#34;&gt;override&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// do something with navigationController&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// but navigationController is nil&lt;/span&gt;
    &lt;span class=&#34;kc&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;navigationController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위 코드에서는 첫 번째 뷰컨트롤러에서 두 번째 뷰컨트롤러로 화면 전환을 하기 전에 configureSecondView 메소드를 통해 두 번째 뷰컨트롤러의 뷰에 접근을 하고 있습니다.&lt;br&gt;
이때, 두 번째 뷰컨트롤러의 viewDidLoad가 호출되며 이 시점에서 두 번째 뷰컨트롤러의 viewDidLoad에서 navigationController는 nil 입니다. moveToSecondView 호출을 하지 않았기 때문에 두 번째 뷰컨트롤러에 네비게이션에 대한 어떠한 동작도 하지 않았기 때문입니다.&lt;/p&gt;
&lt;p&gt;당연히 이런 상황에서 navigationController를 사용하는 코드는 optional chanining에 걸려서 동작하지 않을 것이고 force unwrapping을 하였다면 앱이 터지는 상황까지 갈 것입니다.&lt;/p&gt;
&lt;h3 id=&#34;정리&#34;&gt;정리&lt;/h3&gt;
&lt;p&gt;이와 같이 우리는 viewDidLoad 에서 초기화 및 설정 작업을 해주지만, 여기서 navigationController가 항상 존재하는 것은 아니라는 점을 알고 있어야 합니다.&lt;/p&gt;
&lt;p&gt;자식 뷰컨트롤러의 viewDidLoad에서 navigationController가 없는 상황이 발생할 경우, view에 대한 접근 시점을 화면 전환 이후에 하도록 늦추거나  navigationController를 부모 뷰컨트롤러에서 설정한 후 화면 전환 할 때 해당 navigationController를 통해 화면 전환을 해주면 이러한 상황을 해결할 수 있습니다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>StringFormat 순서 바꾸기</title>
        <link>https://korjaeyoungyun.github.io/p/stringformat-%EC%88%9C%EC%84%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/</link>
        <pubDate>Thu, 30 Dec 2021 01:23:29 +0900</pubDate>
        
        <guid>https://korjaeyoungyun.github.io/p/stringformat-%EC%88%9C%EC%84%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/</guid>
        <description>&lt;img src="https://korjaeyoungyun.github.io/p/stringformat-%EC%88%9C%EC%84%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/brett-jordan-M3cxjDNiLlQ-unsplash.jpg" alt="Featured image of post StringFormat 순서 바꾸기" /&gt;&lt;p&gt;String format을 사용할 때, 인자들의 순서들이 상황에 따라 다르게 적용되도록 하게 해야 할 때가 있습니다.
(다국어 처리 시 시간, 주소의 순서 등&amp;hellip;)&lt;/p&gt;
&lt;p&gt;이를 위해서 &lt;a class=&#34;link&#34; href=&#34;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Strings/Articles/formatSpecifiers.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Swift format&lt;/a&gt;에서는 인자들의 데이터 타입뿐만 아니라 순서 specifier도 제공합니다.
순서 specifier는 &amp;ldquo;n$&amp;rdquo; 형태로 사용되며 포맷 specifier와 결합하여 인자들의 순서를 조절할 수 있습니다.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/korJAEYOUNGYUN/35b009c648f1b4e33038e5e62dbd2939.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;위 코드는 String format에 순서를 적용하는 간단한 예시입니다.&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
